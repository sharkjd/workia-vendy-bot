# --- NaÄtenÃ­ promÄ›nnÃ½ch z .env a prÃ¡ce s prostÅ™edÃ­m ---
import os
from dotenv import load_dotenv
# --- Typy a stav pro LangGraph ---
from typing import Annotated
from typing_extensions import TypedDict
# --- StavovÃ½ graf a redukce zprÃ¡v ---
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
# --- LLM od Google (Gemini) ---
from langchain_google_genai import ChatGoogleGenerativeAI
# --- Telegram Bot API ---
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes

# NovÃ© importy pro databÃ¡zi
from psycopg_pool import ConnectionPool
from langgraph.checkpoint.postgres import PostgresSaver

# NaÄte promÄ›nnÃ© z .env (TELEGRAM_BOT_TOKEN, GEMINI_API_KEY, DATABASE_URL)
load_dotenv()
# URI pÅ™ipojenÃ­ k PostgreSQL (napÅ™. Supabase)
DB_URI = os.getenv("DATABASE_URL")

# Stav grafu: seznam zprÃ¡v, kterÃ© se pÅ™i pÅ™idÃ¡nÃ­ sluÄujÃ­ pÅ™es add_messages (historie chatu)
class AgentState(TypedDict):
    messages: Annotated[list, add_messages]

# Inicializace modelu Gemini; pouÅ¾Ã­vÃ¡ se pro generovÃ¡nÃ­ odpovÄ›dÃ­
llm = ChatGoogleGenerativeAI(
    model="gemini-2.5-flash",
    api_key=os.getenv("GEMINI_API_KEY"),
    temperature=0.7,
    max_tokens=1000,
)

# Uzel grafu: vezme aktuÃ¡lnÃ­ zprÃ¡vy, poÅ¡le je do LLM a vrÃ¡tÃ­ odpovÄ›Ä jako novou zprÃ¡vu
def chatbot_node(state: AgentState) -> AgentState:
    response = llm.invoke(state["messages"])
    return {"messages": [response]}

# SestavenÃ­ grafu: jeden uzel "chatbot", vstup â†’ chatbot â†’ konec
graph = StateGraph(AgentState)
graph.add_node("chatbot", chatbot_node)
graph.add_edge(START, "chatbot")
graph.add_edge("chatbot", END)

# GlobÃ¡lnÃ­ promÄ›nnÃ©, kterÃ© naplnÃ­me aÅ¾ pÅ™i startu programu
graph = None   # zkompilovanÃ½ LangGraph s checkpointerem (pamÄ›Å¥ v DB)
pool = None    # connection pool k PostgreSQL

# Reakce na pÅ™Ã­kaz /start: poÅ¡le uÅ¾ivateli uvÃ­tacÃ­ zprÃ¡vu
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Ahoj! Jsem Vendy a odteÄ si pamatuju, co mi pÃ­Å¡eÅ¡! ğŸ˜")

# Reakce na kaÅ¾dou textovou zprÃ¡vu (kromÄ› pÅ™Ã­kazÅ¯): pÅ™edÃ¡ ji do grafu a odpovÄ›Ä poÅ¡le zpÄ›t
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_text = update.message.text
    # VytÃ¡hneme si unikÃ¡tnÃ­ ID uÅ¾ivatele z Telegramu
    user_id = str(update.message.chat_id)

    # Vstup do grafu: jedna novÃ¡ uÅ¾ivatelskÃ¡ zprÃ¡va (historie se naÄte z DB podle thread_id)
    inputs = {"messages": [("user", user_text)]}

    # NOVÃ‰: Konfigurace s Thread ID
    # TÃ­mto Å™Ã­kÃ¡me LangGraphu, do jakÃ© "sloÅ¾ky" v databÃ¡zi se mÃ¡ podÃ­vat
    config = {"configurable": {"thread_id": user_id}}

    # SpustÃ­me graf a pÅ™edÃ¡me mu i ten config
    result = graph.invoke(inputs, config=config)

    # PoslednÃ­ zprÃ¡va v result je odpovÄ›Ä modelu; jejÃ­ text poÅ¡leme uÅ¾ivateli
    bot_reply = result["messages"][-1].content
    await update.message.reply_text(bot_reply)

# HlavnÃ­ vstupnÃ­ bod: pÅ™ipojÃ­ DB, zkompiluje graf s pamÄ›tÃ­ a spustÃ­ Telegram bota
def main():
    global graph, pool

    print("PÅ™ipojuji se k Supabase...")
    # OtevÅ™eme "bazÃ©n" pÅ™ipojenÃ­ k databÃ¡zi (max 20 spojenÃ­, autocommit pro checkpointer)
    pool = ConnectionPool(
        conninfo=DB_URI,
        max_size=20,
        kwargs={"autocommit": True, "prepare_threshold": None}
    )

    # NOVÃ‰: PÅ™edÃ¡me pÅ™ipojenÃ­ Checkpointeru a ten nÃ¡slednÄ› do grafu
    # PostgresSaver uklÃ¡dÃ¡ stav konverzacÃ­ do PostgreSQL, takÅ¾e kaÅ¾dÃ½ uÅ¾ivatel mÃ¡ vlastnÃ­ historii
    checkpointer = PostgresSaver(pool)
    graph = graph.compile(checkpointer=checkpointer)

    # VytvoÅ™enÃ­ Telegram aplikace s tokenem z .env
    app = Application.builder().token(os.getenv("TELEGRAM_BOT_TOKEN")).build()

    # Registrace handlerÅ¯: /start volÃ¡ start(), ostatnÃ­ textovÃ© zprÃ¡vy volajÃ­ handle_message()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    print("Vendy bÄ›Å¾Ã­ a mÃ¡ pamÄ›Å¥! Zkus si s nÃ­ povÃ­dat na Telegramu.")
    # BlokujÃ­cÃ­ bÄ›h bota â€“ ÄekÃ¡ na novÃ© zprÃ¡vy (long polling)
    app.run_polling()

# SpuÅ¡tÄ›nÃ­ main() jen pÅ™i pÅ™Ã­mÃ©m volÃ¡nÃ­ souboru (ne pÅ™i importu)
if __name__ == "__main__":
    main()